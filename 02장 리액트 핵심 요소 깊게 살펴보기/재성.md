# 2장 리액트 핵심 요소 깊게 살펴보기

## JSX란?

: 페이스북에서 개발한 XML과 유사한 문법을 가진 내장형 구문
다양한 트랜스파일러에서 다양한 속성을 가진 트리 구조를 토근화해 ECMAScript로 변환하기 위해 설계됨

- 즉, JSX는 트랜스파일러를 거쳐 자바스크립트 코드로 변환됨
- JavaScript 코드 내부에 HTML과 같은 트리 구조를 가진 컴포넌트를 표현할 수 있음

## JSX가 변환되는 방식

변환전

```jsx
const ComponentA = <A required={true}>Hello World</A>;
const ComponentB = <>Hello World</>;
const ComponentC = (
  <div>
    <span>hello world</span>
  </div>
);
```

변환후

```jsx
var ComponentA = React.createElement(
  A,
  {
    required: true,
  },
  "Hello World"
);

var ComponentB = React.createElement(React.Fragment, null, "Hello World");
var ComponentC = React.createElement(
  "div",
  null,
  React.createElement("span", null, "hello world")
);
```

즉, JSX 반환값이 React.createElement 함수로 변환됨을 알 수 있다.

## 가상DOM과 리액트 파이버

### DOM과 브라우저 렌더링 과정

Document Object Model : 문서 객체 모델

**브라우저 렌더링 과정**

1. DOM, CSSOM 생성
   - 서버로부터 HTML, CSS를 다운로드 받아 Object Model로 만듬
   - HTML -> DOM tree, CSS -> CSSOM
2. Render Tree 생성
   - 실제 화면에 표현되는 노드들로 구성
3. Layout
   - Render Tree 노드들이 화면의 어느 좌표에 나타나야 하는지 계산함
4. Paint
   - 요소들을 실제 화면에 그려넣음

실제 코드로 보면,

```html
#text{ background-color: red; color: white; } ‹!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="./style.css" />
    <title>Hello React!</title>
  </head>
  <body>
    <div style="width: 100%;">
      <div id="text" style="width: 50%;">Hello world!</div>
    </div>
  </body>
</html>
```

1. HTML 다운로드 및 분석
2. link 태그 발견하면 style.css 다운로드
3. 각 태그의 스타일 계산
4. 다운로드 받은 CSS에 id="text"에 대한 스타일 정보 결합
5. 렌더링 수행

와 같은 순서를 가짐.

### 가상 DOM의 탄생 배경

브라우저가 웹페이지를 렌더링하는 것은 매우 복잡하고 비용이 많이 드는 과정임
요소의 노출 여부, 사이즈가 변경되는 등과 같은 요소의 위치와 크기를 재계산하는 경우, 레이아웃이 일어나고 리페인팅도 필연적으로 발생함. → 비용 증가

요즘과 같이 하나의 인터랙션으로 여러 요소들이 변하는 웹페이지들에서는 이러한 추가적인 렌더링 작업을 최소화해야함

이 문제를 해결하기 위해 **가상 DOM**이 만들어짐.
가상 DOM은 DOM을 메모리에 저장하고 리액트가 실제 변경에 대한 준비과 완료됐을 떄 실제 브라우저의 DOM에 반영함.
이렇게 DOM에 대한 계산을 매번 브라우저가 아니라 메모리에서 계산되게끔하는 과정을 거치게된다면 실제 DOM에서 발생했을 렌더링 비용을 최소화할 수 있음

<aside>
가상돔에 대한 오해

다만 가상 DOM이 일반적인 DOM보다 빠르다는 오해가 있는데, 이는 사실이 아닙니다. 무조건 빠른것이 아니라 대부분의 상황에서 웬만한 어플리케이션을 만들때 사용될수있을만큼 충분히 빠르다는 것이고 개발 시 렌더링 방식에 있어 좀 더 효율적인 매커니즘을 채택했다고 보는것이 옳습니다.

</aside>

### 리액트 파이버

React Fiber는 리액트에서 관리하는 평범한 자바스크립트 객체
가상 DOM과 실제 DOM을 스냅샷 단위로 비교하며 변경사항을 수집해 만약 이 둘 사이에 차이가 있으면 변경에 관련된 정보를 가지고있는 파이버를 기준으로 화면에 렌더링을 요청하는 역할을 함.

즉 리액트에서 어떤 부분을 새롭게 렌더링해야하는지 가상 DOM과 실제 DOM을 비교하는 알고리즘이라고 보면 되는데, 파이버는 다음과 같은 일을 할 수 있음.

- 작업을 작은 단위로 분할하고 쪼갠다음 우선순위를 매김
- 이러한 작업 단위는 일시 중단하고 다시 시작될 수도 있음
- 이전에 했던 작업을 재사용하거나 필요하지않은경우 폐기할 수 있음

**중요한것은 이 모든 과정이 비동기로 일어남.**

파이버는 하나의 작업 단위로 구성. 리액트는 이 작업 단위를 하나씩 처리하고 finishedWork()라는 작업으로 마무리함. 이후 이 작업을 커밋해 실제 브라우저 DOM에 가시적인 변경 사항을 만들어 냄

두 단계로 나누면,

1. 렌더 단계, 리액트는 사용자에게 노출 되지 않는 모든 비동기 작업을 수행. 그리고 이 단계에서 앞서 언급 한 파이버의 작업 , 우선순위를 지정하거나 중지시키거나 버리는 등 의 작업이 일어남
2. 커밋 단계, 앞서 언급 한 것처럼 DOM 에 실제 변경 사항을 반영하기 위한 작업 , commitWork() 가 실행되는데 , 이 과정은 앞서 와 다르게 동기 식 으로 일어나고 중단될 수도 없음

파이버 객체의 생성 지점은 컴포넌트가 최초로 마운트되는 시점에 생성되고 이후에 재사용될 수 있음
파이버 객체는 하나의 element에 하나가 생성되는 1:1 관계를 가지고 있음

생성된 파이버는 state 가 변경되거나 생명주기 메서드가 실행되거나 DOM 의 변경이 필요한 시점 등에 실행됨.
중요한 것은 리액트가 파이버를 처리할 때마다 이러한 작업을 우선순위에 따라 유연하게 처리한다는 것.

정리하자면, 이러한 리액트 내에서 처리되는 비동기 작업과 달리 실제 브라우저 구조인 DOM에서 변화를 반영하는것은 동기적으로 일어나야하고 화면에 불완전하게 표시될 가능성이 높으므로 이러한 작업을 미리 가상에서, 즉 메모리 상에서 한차례 수행한 이후 최종적인 결과물만 실제 DOM에 반영하는 매커니즘이 가상 DOM임.

### 클래스 컴포넌트와 함수 컴포넌트

**클래스 컴포넌트**

- React.Component를 상속받아 정의함.
- 생명주기 메서드(componentDidMount, componentDidUpdate, componentWillUnmount 등)를 활용할 수 있음.

```jsx
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.increment}>Increase</button>
      </div>
    );
  }
}
```

다음과 같은 문제점으로 인해 현재는 잘 사용되지 않음

- 데이터의 흐름을 추적하기 어려움
  - 서로 다른 여러 메서드에서 state 의 업데이트가 일어날 수 있으며 , 또 코드 작성 시 메서드의 순서가 강제돼 있는 것이 아니기 때문에 사람이 읽기가 매우 어려움
- 애플리케이션 내부 로직의 재사용이 어려움
  - 공통 로직이 많아질수록 이를 감싸는 고차 컴포넌트, props가 많아지는 래퍼지옥에 빠질 수 있음
- 기능이 많아질수록 컴포넌트의 크기가 커짐
- 클래스는 함수에 비해 상대적으로 어려움
- 코드 크기 최적화하기 어려움
- 핫 리로딩을 하는데 상대적으로 불리함

**함수 컴포넌트**

리액트 16.8 버전 이전에는 단순히 무상태 컴포넌트를 구현하기 위한 하나의 수단에 불과했음

이후 Hooks가 도입되면서 기본적인 방식으로 자리 잡음.

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increase</button>
    </div>
  );
}
```

**함수 컴포넌트 VS 클래스 컴포넌트**

- 생명주기 메서드의 부재
  - 함수 컴포넌트는 proops를 받아 리액트 요소만 반환하는 함수이므로 생명주기 메서드를 사용하지 않음
  - 대신 useEffect 훅을 사용해 **비슷하게** 구현할 수 있음(똑같이 구현x)
- 함수 컴포넌트와 렌더링된 값
  - 함수 컴포넌트는 렌더링된 값을 고정
  - 클래스 컴포넌트는 고정하지 않음
    - this에 바인딩된 props를 사용함. 즉 this가 가리키는 객체(컴포넌트의 인스턴스의 멤버)는 변경 가능한 값. 따라서 리액트의 생명주기 메서드가 변경된 값을 읽을 수 있음

<aside>
👉 현재 React 개발에서는 함수 컴포넌트가 주로 사용되며, 새로운 프로젝트에서는 함수 컴포넌트를 기본적으로 선택하는 것이 권장됨
</aside>

### 렌더링은 어떻게 일어나는가?

- 브라우저에서 렌더링
  - HTML 과 CSS 리소스를 기반으로 웹페이지에 필요한 UI를 그리는 과정
- 리액트에서 렌더링
  - 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props 와 state 의 값을 기반으로 어떻게 UI 를 구성하고 이를 바탕으로 어떤 DOM 결과 를 브 라우저에 제공할 것인지 계산 하는 일련의 과정
  쉽게 말해, 브라우저가 렌더링에 필요한 DOM 트리를 만드는 과정

**리액트에서 렌더링이 발생하는 경우**

1. 최초 렌더링
2. 리렌더링
   1. 클래스 컴포넌트의 setState가 실행되는 경우
   2. 클래스 컴포넌트의 forceUpdate가 실행되는 경우
   3. 함수 컴포넌트의 useState()의 setter가 실행되는 경우
   4. 함수 컴포넌트의 useReducer의 dispatch가 실행되는 경우
   5. 컴포넌트의 key props가 변경되는 경우

<aside>
👉 배열에 key를 추가하는 이유

리액트에서 key 는 리렌더링이 발생하는 동안 형제 요소들 사이에서 동일한 요소를 식별하는 값임.
동일한 자식 컴포넌트가 여러 개 있는 구조일 경우 두 트리 사이에서 동일한 key 를 가지고 있는 컴포넌트는 이를 기준으로 구별할 수 있지만, 이 key 가 없다면 단순히 파이버 내부의 sibling 인덱스만을 판단해야 하므로 구별하기엔 한계가 있음

</aside>

**렌더와 커밋**

- 렌더 단계 (Render Phase)
  - 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업.
  - 즉, 렌더링 프로세스에서 컴포넌트를 실행해 (render() 또는 return) 이 결과와 이전 가상 DOM 을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계
  - type, props, key 중 하나라도 변경된 것이 있으면 변경이 필요한 컴포넌트로 체크함
- 커밋 단계 (Commit Phase)
  - 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정
  - 이 단계가 끝나야 비로소 브라우저의 렌더링이 발생

**리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아님**

렌더링을 수행했으나 커밋 단계까지 갈 필요가 없다면, 즉 변경 사항을 계산했는데 아무런 변경 사항이 감지되지 않는다면 이 커밋 단계는 생략될 수 있음.

즉 리액트의 렌더링은 꼭 가시적인 변경이 일어나지 않아도 발생할 수 있다.

컴포넌트를 렌더링하는 작업은 하위 모든 컴포넌트에 영향을 미침

부모가 변경됐다면 Pops가 변경됐는지와 상관없이 무조건 자식 컴포넌트도 리렌더링됨

## 메모이제이션

useMemo, useCallback 훅과 고차 컴포넌트인 memo는 리액트에서 발생하는 렌더링을 최소한으로 줄이기 위해 제공됨

그렇다면 메모이제이션 최적화는 어떤 기준으로 해야할까?

### 주장1) 필요한 곳에만 메모이제이션을 추가하자

메모이제이션은 값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업, 이전 결과물을 캐시로 저장했다가 꺼내오는 두 가지 비용이 있다. 즉, 간단한 함수일 경우 리렌더링 비용이 메모이제이션하는 비용보다 저렴할 것이다.

따라서 항상 메모이제이션은 신중하게 접근해야 하며 섣부른 최적화는 항상 경계해야 한다.

### 주장2) 렌더링 과정은 비싼 작업. 모두 메모이제이션하자.

큰 규모의 프로젝인 경우 최적화와 성능 향상에 많은 시간을 투자할 수 없음. 따라서 일단 memo로 다 감싸버리자.

메모이제이션은 하지 않는 것보다 메모이제이션했을 때 더 많은 이점을 누릴 수 있음. 이것이 비록 섣부른 초기화라 할지라도 했을 때 누릴 수 있는 이점 , 그리고 이를 실수로 빠트렸을 때 치러야 할 위험 비용이 더 크기 때문에 최적화에 대한 확신이 없다면 가능한 한 모든곳에 메모이제이션을 활용한 최적화를 하는 것이 좋다.
